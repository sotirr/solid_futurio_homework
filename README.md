![workflow](https://github.com/sotirr/solid_futurio_homework/actions/workflows/codecow-workflow.yml/badge.svg)
[![codecov](https://codecov.io/gh/sotirr/solid_futurio_homework/branch/main/graph/badge.svg?token=MFFSQUEQ74)](https://codecov.io/gh/sotirr/solid_futurio_homework)

# Задание  

В далекой звездной системе встретились две флотилии космических кораблей. Корабли могут передвигаться по всему пространству звездной системы по прямой, поворачиваться против и по часовой стрелке, стрелять фотонными торпедами. Попадание фотонной торпеды в корабль выводит его из строя.

От каждой флотилии в сражении принимают участие по три космических корабля.

Победу в битве одерживает та флотилия, которая  первой выведет из строя все корабли соперника.

Управление флотилиями осуществляется игрокам компьютерными программами (то есть не с клавиатуры).

**Концептуально игра состоит из трех подсистем**:

1. Игровой сервер, где реализуется вся игровая логика.

2. Player - консольное приложение, на котором отображается конкретная битва.

3. Агент - приложение, которое запускает программу управления танками от имени игрока и отправляет управляющие команды на игровой сервер.

## ДЗ№1 Реализовать движение объектов на игровом поле в рамках подсистемы Игровой сервер

### Definition of Done критерии

**Complexity Level #1**:

1. Прямолинейное равномерное движение без деформации.
   1. Само движение реализовано в виде отдельного класса
   2. Для движущихся объектов определен интерфейс, устойчивый к появлению новых видов движущихся объектов

2. Поворот объекта вокруг оси.
   1. Сам поворот реализован в виде отдельного класса
   2. Для поворачивающегося объекта определен интерфейс, устойчивый к появлению новых видов движущихся объектов

3. Код решения опубликован на github/gitlab в отдельной ветке.

4. Код компилируется без ошибок

**Complexity Level #2**:

1. Реализован тест: Для объекта, находящегося в точке (12, 5) и движущегося со скоростью (-7, 3) движение меняет положение объекта на (5, 8)

2. Реализован тест: Попытка сдвинуть объект, у которого невозможно прочитать положение объекта в пространстве,, приводит к ошибке

3. Реализован тест: Попытка сдвинуть объект, у которого невозможно прочитать значение мгновенной скорости, приводит к ошибке

4. Реализован тест: Попытка сдвинуть объект, у которого невозможно изменить положение в пространстве, приводит к ошибке

5. Все тесты успешно выполняются

**Complexity Level #3**:

1. Реализованы тесты для поворота корабля вокруг собственной оси.

2. Настроен расчет покрытия кода тестами.

3. Настроен CI, который умеет собирать проект и прогонять тесты, вычислять покрытие кода тестами.

4. Покрытие кода тестами 100%.

5. Пайплайн “зеленый”


## ДЗ№2. Реализовать операции начала и завершения длительных операций в рамках подсистемы Игровой сервер.

Поступательное движение и поворот - это длительные операции. Под длительностью здесь понимается не то, что время их выполнения может быть минуты, часы или годы. Длительность, с точки зрения вычислимости, описанной дейкстрой (см. занятие №1) означает, что мы можем наблюдать промежуточное состояние этого объекта в процессе выполнения длительной операции. Другими словами длительная операция - это операция, которая выполняется не атомарным образом. А значит у этой операции есть начало и конец. В рамках этого домашнего задания предстоит реализовать операции начала длительной операции Start и завершения длительной операции End.

Для реализации этой задачи предположим, что у нас все операции, например, move, rotate, имеют один общий интерфейс:

```
interface Command
{
	void Execute();
}
``` 

Все команды игры хранятся в очереди Queue. Как будет производиться работа с очередью - будет определено в следующих ДЗ. Сейчас достаточно считать, что результат работы команды Start Заключается в том, что команда, например, Move или Rotate, ставится в очередь, а результат команды End заключается в том, что соответствующая команда, например,  Move или Rotate, удаляется из очереди команд.

### Definition of Done критерии

**Complexity Level #1**:

1. Реализована операция StartMoveCommand
   1. Определен интерфейс MoveCommandStartable, с помощью которого можно получить экземпляр UObject - объект, который будет двигаться по прямой, целочисленное значение Velocity - модуль мгновенной скорости, с которой начинает двигаться объект, Queue[Command] - очередь команд, куда будет записана команда созданная команда Move.  

      *!Обратить внимание. Интерфейс MoveCommandStartable будет оберткой не над космическим кораблем или торпедой, а над приказом, который главнокомандующий флотом отправляет своему кораблю. Этот приказ тоже будет представлен UObject (приказ передается от одного процесса к другому и требует сериализации.десериализации). Приказ можно представить себе как следующий json-объект*:

      ```json
      {
         “id”: “уникальный идентификатор объекта, которому отдан приказ”,
         “action”: “код операции”, //например, “startMove”, “stopMove”, “fire” и т.д.
         // параметры, специфичные для самого приказа
         “velocity”: 2
      }
      ```

   2. Реализована команда StartMoveCommand, которая
      - записывает значение скорости в движущийся объект  
         !Указание. Изменение скорости лучше сделать через отдельную команду, для которой определен отдельный интерфейс для изменения скорости.
      - создает адаптер MovableAdapter для движущегося объекта
      - создает команду MoveCommand
      - кладет команду MoveCommand в очередь

2. Реализована операция EndMoveCommand
   1. Реализован интерфейс MoveCommandEndable, который возвращает команду Move, которую необходимо завершить, объект, который движется с помощью данной команды, очередь команд Queue[Command]
   2. Реализована команда EndMoveCommand, которая
      - удаляет значение скорости из движущегося объекта.  
         *!Указание. Самая простая реализация потребует добавление в интерфейс UObject метода, который удаляет значение по ключу. Вообще, это является нарушением OCP, но предлагаю сделать сейчас так, чтобы не усложнять понимание всего процесса работы с SOLID на данном этапе обучения.*
      - удаляет команду Move из Очереди команд.  
         *!Указание. Это не самый оптимальный вариант реализации, так как потребует просматривать команды, которые находятся в очереди и временные затраты на эту операцию будут пропорциональны длине очереди.*

3. Код решения опубликован на github/gitlab в отдельной ветке.
4. Код компилируется без ошибок
